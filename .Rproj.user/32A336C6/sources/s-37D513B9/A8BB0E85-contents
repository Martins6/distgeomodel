# Title: Criteria for automatic selection of autocorrelation function based ond the haversine variogram
# Author: Adriel Martins
# Date: 02/03/2020

#' Fitting multiple variogram models using haversine distance (default) or euclidean.
#'
#' @param df A dataframe that has 'value' and two coordinates columns 'lat', 'long' for haversine or 'x' and 'y' for euclidean.
#' @param distance Type of distance to be choosen.
#' @param model_classes Classes of variogram models to be considered.
#' @param weight_types Weights considered in the fitting of the variogram models.
#' @param best_model_criteria The criteria to be taken for the choosing of the best model.
#' @return A list containing all the results of the combinations of the model and a gstat object of the best model.
auto_krige_model_CV_haversine <- function(df, distance = 'haversine',
                                                  best_model_criteria = 'MSE', max.dist,
                                                  model_classes = c("matern", "exponential", "gaussian", "spherical"),
                                                  weights_types = c("npairs", "cressie", "equal")){

  dt <- df
  model.classes <- model_classes
  weight.types <-  weights_types

  # If distance = 'haversine',
  # dt must have 'lat' and 'long' columns, with only other column, named 'value'.
  # If distance = 'euclidean",
  # dt must have 'x' and 'y' columns, with only other column, named 'value'.

  # Transforming to geodata
  dt.geo <- dt %>% as.geodata()

  # Modelling Variogram with the SSE minimization
  if(distance == 'haversine'){

    if (missing(max.dist)) {
      # Variogram with Geodesic Distance
      v <- variog.geodesic(dt.geo)
    } else{
      v <- variog.geodesic(dt.geo, max.dist = max.dist)
    }

  }
  if(distance == 'euclidean'){
    aux.bin <- dt.geo$coords %>%
      dist(method = 'euclidean') %>%
      vectorizing_fun()

    if(missing(max.dist)){max.dist <- max(aux.bin)}

    aux.bin1 <- aux.bin[aux.bin < max.dist] %>%
      quantile(probs = seq(0,1, l = 12))
    # Variogram with Euclidean Distance
    v <- variog(geodata = dt.geo, uvec = aux.bin1)
  }

  # Our loop to find the best model for the variogram or autocorrelation function based on the SSE
  res <- tibble(Vario.Model = NA, Vario.MSSErr = NA, Vario.Weights = NA,
                Krige.CV.MSE = NA, Krige.CV.MAE = NA, Kappa_Matern = NA)
  # Modelling Variogram
  for(j in weights.types){
    for(i in model.classes){
      if(i == 'matern'){
        for(kap in c(1, 1.5)){
          # fit the variogram
          ols.fit <- variofit(v, cov.model = i, weights = j,
                              fix.kappa = T, kappa = kap, messages = F)
          # Changing from GeoR to GSTAT form
          # Adapting the name of the model so that it can fit in the gstat form
          model.gstat <- as.character(i) %>%
            stringr::str_sub(1L, 3L) %>%
            str_to_title()

          if(ols.fit$cov.pars[2] == 0){
            warning(paste('Numeric Error in fitting of the following model:', i, kap, j))
            next
          }
          var.fit <- vgm(psill = ols.fit$cov.pars[1],
                         model = model.gstat,
                         range = ols.fit$cov.pars[2],
                         nugget = ols.fit$nugget,
                         cutoff = ols.fit$max.dist)

          # Calculating the diference
          fit.cov <- variogramLine(var.fit, max(v$u), dist_vector = v$u)$gamma
          diff.cov <- v$v - fit.cov
          MSSErr <- mean(diff.cov^2)

          if(distance == 'haversine'){
            cv <- cv_geodesic(dt, var.fit)
          }
          if(distance == 'euclidean'){
            cv <- cv_geodesic(dt, var.fit, distance = 'euclidean')
          }

          # MAE and MSE
          aux <- cv %>%
            summarise(MAE = mean(abs(z.score)),
                      MSE = mean(z.score^2))
          # Add the parameters to our auxiliary tibble
          res <- res %>%
            add_row(tibble_row(Vario.Model = i, Vario.MSSErr = MSSErr), Vario.Weights = j,
                    Krige.CV.MSE = aux$MSE, Krige.CV.MAE = aux$MAE, Kappa_Matern = kap)

        }
        next
      }
      # fit the variogram
      ols.fit <- variofit(v, cov.model = i, weights = j, messages = F)
      # Changing from GeoR to GSTAT form
      # Adapting the name of the model so that it can fit in the gstat form
      model.gstat <- as.character(i) %>%
        stringr::str_sub(1L, 3L) %>%
        str_to_title()

      if(ols.fit$cov.pars[2] == 0){
        warning(paste('Numeric Error in fitting of the following model:', i, j))
        next
      }
      var.fit <- vgm(psill = ols.fit$cov.pars[1],
                     model = model.gstat,
                     range = ols.fit$cov.pars[2],
                     nugget = ols.fit$nugget,
                     cutoff = ols.fit$max.dist)

      # Calculating the diference
      fit.cov <- variogramLine(var.fit, max(v$u), dist_vector = v$u)$gamma
      diff.cov <- v$v - fit.cov
      MSSErr <- mean(diff.cov^2)

      if(distance == 'haversine'){
        cv <- cv_geodesic(dt, var.fit)
      }
      if(distance == 'euclidean'){
        cv <- cv_geodesic(dt, var.fit, distance = 'euclidean')
      }

      # MAE and MSE
      aux <- cv %>%
        summarise(MAE = mean(abs(z.score)),
                  MSE = mean(z.score^2))
      # Add the parameters to our auxiliary tibble
      res <- res %>%
        add_row(tibble_row(Vario.Model = i, Vario.MSSErr = MSSErr), Vario.Weights = j,
                Krige.CV.MSE = aux$MSE, Krige.CV.MAE = aux$MAE, Kappa_Matern = NA)
    }
  }
  print(res)
  # Finding the model that minimizes the best_model_criteria
  column <- str_c(c('Krige.CV.', best_model_criteria), collapse = '')
  best.model <- res %>%
    filter(!is.na(Vario.Model)) %>%
    filter(.data[[column]] == min(.data[[column]]))

  print(best.model)
  # Fitting the optimal variogram
  ols.fit <- variofit(v,
                      cov.model = as.character(best.model[1,1]),
                      weights = as.character(best.model[1,3]),
                      messages = F)

  # Changing from GeoR to GSTAT form
  # Adapting the name of the model so that it can fit in the gstat form
  model.gstat <- as.character(best.model[1,1]) %>%
    stringr::str_sub(1L, 3L) %>%
    str_to_title()

  var.fit <- vgm(psill = ols.fit$cov.pars[1],
                 model = model.gstat,
                 range = ols.fit$cov.pars[2],
                 nugget = ols.fit$nugget,
                 cutoff = ols.fit$max.dist)
  print(res)
  res <- res %>%
    # Filtering the first row
    filter(!is.na(Vario.Model)) %>%
    rowwise() %>%
    mutate(Vario.Model = if_else(!is.na(Kappa_Matern),
                                 str_c(Vario.Model, ' (Phi = ', as.character(Kappa_Matern), ')'),
                                 Vario.Model)) %>%
    ungroup() %>%
    select(-Kappa_Matern)

  print(res)
  return(list(Results = res, var.fit.best.model = var.fit))
}
