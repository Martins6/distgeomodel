# Title: Criteria for automatic selection of autocorrelation function based ond the haversine variogram
# Author: Adriel Martins
# Date: 02/03/2020
################****************************
# Libraries
# Source the code for the functions, with the dependent libraries.
# source('my_codes/Kriging.R')
# source('my_codes/Variogram_Geodesic_Fitting_Function.R')
# source('my_codes/Cross_Validation_Geodesic.R')
############################################ MINIMIZING MSSER VARIOGRAM ################################
autofit.Variogram.Geodesic <- function(dt, distance = 'haversine', max.dist){
  
  # If distance = 'haversine',
  # dt must have 'lat' and 'long' columns, with only other column, named 'value'.
  # If distance = 'euclidean",
  # dt must have 'x' and 'y' columns, with only other column, named 'value'.
  
  # Transforming to geodata
  dt.geo <- dt %>% as.geodata()
  
  # Modelling Variogram with the SSE minimization
  # All the model classes
  model.classes <- c("matern", "exponential", "gaussian", "spherical")
  # All the Weight Types
  weights.types <- c("npairs", "cressie", "equal")
  
  if(distance == 'haversine'){
    
    if (missing(max.dist)) {
      # Variogram with Geodesic Distance
      v <- variog.geodesic(dt.geo)
    } else{
      v <- variog.geodesic(dt.geo, max.dist = max.dist)
    }
    
  }
  if(distance == 'euclidean'){
    aux.bin <- dt.geo$coords %>%
      dist(method = 'euclidean') %>%
      vectorizing_fun() 
    
    if(missing(max.dist)){max.dist <- max(aux.bin)}
    
    aux.bin1 <- aux.bin[aux.bin < max.dist] %>%
      quantile(probs = seq(0,1, l = 12))
    # Variogram with Euclidean Distance
    v <- variog(geodata = dt.geo, uvec = aux.bin1)
  }
  
  # Our loop to find the best model for the variogram or autocorrelation function based on the SSE
  res <- tibble(Model = NA, MSSErr = NA, Weights = NA, Kappa_Matern = NA)
  # Modelling Variogram
  for(j in weights.types){
    for(i in model.classes){
      if(i == 'matern'){
        for(kap in c(1, 1.5)){
          # fit the variogram
          ols.fit <- variofit(v, cov.model = i, weights = j,
                              fix.kappa = T, kappa = kap, messages = F)
          # Transforming to gstat form
          model.gstat <- as.character(i) %>%
            stringr::str_sub(1L, 3L) %>% 
            str_to_title()
          
          if(ols.fit$cov.pars[2] == 0){
            warning(paste('Numeric Error in fitting of the following model:', i, kap, j))
            next
          }
          
          var.fit <- vgm(psill = ols.fit$cov.pars[1],
                         model = model.gstat,
                         range = ols.fit$cov.pars[2],
                         nugget = ols.fit$nugget,
                         cutoff = ols.fit$max.dist)
          
          # Calculating the diference 
          fit.cov <- variogramLine(var.fit, max(v$u), dist_vector = v$u)$gamma
          diff.cov <- v$v - fit.cov
          MSSErr <- mean(diff.cov^2) 
          # Add the parameters to our auxiliary tibble
          res <- res %>% 
            add_row(tibble_row(Model = i, MSSErr = MSSErr), Weights = j, Kappa_Matern = kap)
        }
        next
      }
      
      # fit the variogram
      ols.fit <- variofit(v, cov.model = i, weights = j, messages = F)
      # Transforming to gstat form
      model.gstat <- as.character(i) %>%
        stringr::str_sub(1L, 3L) %>% 
        str_to_title()
      
      if(ols.fit$cov.pars[2] == 0){next}
      
      var.fit <- vgm(psill = ols.fit$cov.pars[1],
                     model = model.gstat,
                     range = ols.fit$cov.pars[2],
                     nugget = ols.fit$nugget,
                     cutoff = ols.fit$max.dist)
      
      # Calculating the diference 
      fit.cov <- variogramLine(var.fit, max(v$u), dist_vector = v$u)$gamma
      diff.cov <- v$v - fit.cov
      MSSErr <- mean(diff.cov^2) 
      # Add the parameters to our auxiliary tibble
      res <- res %>% 
        add_row(tibble_row(Model = i, MSSErr = MSSErr), Weights = j, Kappa_Matern = NA)
    }
  }
  
  # Finding the model that minimizes the SSE
  best.model <- res %>% 
    filter(!is.na(Model)) %>% 
    filter(MSSErr == min(MSSErr))
  
  # Fitting the optimal variogram
  ols.fit <- variofit(v,
                      cov.model = as.character(best.model[1,1]),
                      weights = as.character(best.model[1,3]),
                      messages = F)
  
  # Changing from GeoR to GSTAT form
  # Adapting the name of the model so that it can fit in the gstat form
  model.gstat <- as.character(best.model[1,1]) %>%
    stringr::str_sub(1L, 3L) %>% 
    str_to_title()
  
  print(model.gstat)
  
  var.fit <- vgm(psill = ols.fit$cov.pars[1],
                 model = model.gstat,
                 range = ols.fit$cov.pars[2],
                 nugget = ols.fit$nugget,
                 cutoff = ols.fit$max.dist)
  
  # Plotting the results
  a <- cbind(v$v, v$u, v$n) %>%
    as_tibble(.name_repair = 'unique') %>% 
    `colnames<-`(c('gamma', 'dist', 'n'))
  
  b <- variogramLine(var.fit, maxdist = max(v$u)) %>% as_tibble()
  
  if(distance == 'haversine'){
    title.plot <- 'Modelo Ótimo de Autocorrelação com a distância de haversine'
  }else{
    title.plot <- 'Modelo Ótimo de Autocorrelação com a distância euclidiana'
  }
  
  plot.variog.fit <- ggplot() +
    # Variogram points
    geom_point(aes(x = dist, y = gamma), a) +
    # Labels for each of the variogram points indicating how much points there are on each distance class
    geom_text(aes(x = dist, y = gamma, label = n),
              data = a, nudge_x = 10000) +
    # Autocorrelation function
    geom_path(aes(x = dist, y = gamma), b) +
    # Best model annotation
    geom_text(aes(x = a$dist[length(a$dist)], y = a$gamma[1]),
              label = paste('MSQR:', round(best.model[1,2], 3))) +
    labs(x = 'Distância',
         y = 'Semivariância', 
         title = title.plot,
         subtitle = paste('Família:', str_to_title(best.model[1,1]),
                          ' ',
                          'Peso:', str_to_title(best.model[1,3]))) +
    theme_bw()
  
  res <- res %>%
    # Filtering the first row
    filter(!is.na(Model)) %>%
    rowwise() %>% 
    mutate(Model = if_else(!is.na(Kappa_Matern), 
                           str_c(Model, ' (Phi = ', as.character(Kappa_Matern), ')'),
                           Model)) %>% 
    ungroup() %>% 
    select(-Kappa_Matern)
  
  return(list(plot = plot.variog.fit, variogram = var.fit,
              best.models = best.model, Results = res))
  
}
############################################ CV ON KRIGING ########################################
auto.Krige.Model.CV_On_Krige.Geodesic <- function(dt, distance = 'haversine',
                                                  best_model_criteria = 'MSE', max.dist,
                                                  model.classes = c("matern", "exponential", "gaussian", "spherical"),
                                                  weights.types = c("npairs", "cressie", "equal")){
  
  # If distance = 'haversine',
  # dt must have 'lat' and 'long' columns, with only other column, named 'value'.
  # If distance = 'euclidean",
  # dt must have 'x' and 'y' columns, with only other column, named 'value'.
  
  # Transforming to geodata
  dt.geo <- dt %>% as.geodata()
  
  # Modelling Variogram with the SSE minimization
  if(distance == 'haversine'){
    
    if (missing(max.dist)) {
      # Variogram with Geodesic Distance
      v <- variog.geodesic(dt.geo)
    } else{
      v <- variog.geodesic(dt.geo, max.dist = max.dist)
    }
    
  }
  if(distance == 'euclidean'){
    aux.bin <- dt.geo$coords %>%
      dist(method = 'euclidean') %>%
      vectorizing_fun() 
    
    if(missing(max.dist)){max.dist <- max(aux.bin)}
    
    aux.bin1 <- aux.bin[aux.bin < max.dist] %>%
      quantile(probs = seq(0,1, l = 12))
    # Variogram with Euclidean Distance
    v <- variog(geodata = dt.geo, uvec = aux.bin1)
  }
  
  # Our loop to find the best model for the variogram or autocorrelation function based on the SSE
  res <- tibble(Vario.Model = NA, Vario.MSSErr = NA, Vario.Weights = NA,
  Krige.CV.MSE = NA, Krige.CV.MAE = NA, Kappa_Matern = NA)
  # Modelling Variogram
  for(j in weights.types){
    for(i in model.classes){
      if(i == 'matern'){
        for(kap in c(1, 1.5)){
          # fit the variogram
          ols.fit <- variofit(v, cov.model = i, weights = j,
                              fix.kappa = T, kappa = kap, messages = F)
          # Changing from GeoR to GSTAT form
          # Adapting the name of the model so that it can fit in the gstat form
          model.gstat <- as.character(i) %>%
            stringr::str_sub(1L, 3L) %>% 
            str_to_title()
          
          if(ols.fit$cov.pars[2] == 0){
            warning(paste('Numeric Error in fitting of the following model:', i, kap, j))
            next
          }
          var.fit <- vgm(psill = ols.fit$cov.pars[1],
                         model = model.gstat,
                         range = ols.fit$cov.pars[2],
                         nugget = ols.fit$nugget,
                         cutoff = ols.fit$max.dist)
          
          # Calculating the diference 
          fit.cov <- variogramLine(var.fit, max(v$u), dist_vector = v$u)$gamma
          diff.cov <- v$v - fit.cov
          MSSErr <- mean(diff.cov^2) 
          
          if(distance == 'haversine'){
            cv <- cv_geodesic(dt, var.fit)
          }
          if(distance == 'euclidean'){
            cv <- cv_geodesic(dt, var.fit, distance = 'euclidean')
          }
          
          # MAE and MSE
          aux <- cv %>% 
            summarise(MAE = mean(abs(z.score)),
                      MSE = mean(z.score^2))
          # Add the parameters to our auxiliary tibble
          res <- res %>% 
            add_row(tibble_row(Vario.Model = i, Vario.MSSErr = MSSErr), Vario.Weights = j,
                    Krige.CV.MSE = aux$MSE, Krige.CV.MAE = aux$MAE, Kappa_Matern = kap)
          
        }
        next
      }
        # fit the variogram
        ols.fit <- variofit(v, cov.model = i, weights = j, messages = F)
        # Changing from GeoR to GSTAT form
        # Adapting the name of the model so that it can fit in the gstat form
        model.gstat <- as.character(i) %>%
          stringr::str_sub(1L, 3L) %>% 
          str_to_title()
        
        if(ols.fit$cov.pars[2] == 0){
          warning(paste('Numeric Error in fitting of the following model:', i, j))
          next
        }
        var.fit <- vgm(psill = ols.fit$cov.pars[1],
                       model = model.gstat,
                       range = ols.fit$cov.pars[2],
                       nugget = ols.fit$nugget,
                       cutoff = ols.fit$max.dist)

        # Calculating the diference 
        fit.cov <- variogramLine(var.fit, max(v$u), dist_vector = v$u)$gamma
        diff.cov <- v$v - fit.cov
        MSSErr <- mean(diff.cov^2) 
        
        if(distance == 'haversine'){
          cv <- cv_geodesic(dt, var.fit)
        }
        if(distance == 'euclidean'){
          cv <- cv_geodesic(dt, var.fit, distance = 'euclidean')
        }
        
        # MAE and MSE
        aux <- cv %>% 
          summarise(MAE = mean(abs(z.score)),
                    MSE = mean(z.score^2))
        # Add the parameters to our auxiliary tibble
        res <- res %>% 
          add_row(tibble_row(Vario.Model = i, Vario.MSSErr = MSSErr), Vario.Weights = j,
                  Krige.CV.MSE = aux$MSE, Krige.CV.MAE = aux$MAE, Kappa_Matern = NA)
      }
  }
  print(res)
  # Finding the model that minimizes the best_model_criteria
  column <- str_c(c('Krige.CV.', best_model_criteria), collapse = '')
  best.model <- res %>%
    filter(!is.na(Vario.Model)) %>% 
    filter(.data[[column]] == min(.data[[column]]))
  
  print(best.model)
  # Fitting the optimal variogram
  ols.fit <- variofit(v,
                      cov.model = as.character(best.model[1,1]),
                      weights = as.character(best.model[1,3]),
                      messages = F)
  
  # Changing from GeoR to GSTAT form
  # Adapting the name of the model so that it can fit in the gstat form
  model.gstat <- as.character(best.model[1,1]) %>%
    stringr::str_sub(1L, 3L) %>% 
    str_to_title()
  
  var.fit <- vgm(psill = ols.fit$cov.pars[1],
                 model = model.gstat,
                 range = ols.fit$cov.pars[2],
                 nugget = ols.fit$nugget,
                 cutoff = ols.fit$max.dist)
  print(res)
  res <- res %>%
    # Filtering the first row
    filter(!is.na(Vario.Model)) %>%
    rowwise() %>% 
    mutate(Vario.Model = if_else(!is.na(Kappa_Matern), 
                           str_c(Vario.Model, ' (Phi = ', as.character(Kappa_Matern), ')'),
                           Vario.Model)) %>% 
    ungroup() %>% 
    select(-Kappa_Matern)
  
  print(res)
  return(list(Results = res, var.fit.best.model = var.fit))
}
# CV ON DATA
# auto.Krige.Model.CV_On_Data.Geodesic <- function(dt, distance = 'haversine'){
#   
#   # If distance = 'haversine',
#   # dt must have 'lat' and 'long' columns, with only other column, named 'value'.
#   # If distance = 'euclidean",
#   # dt must have 'x' and 'y' columns, with only other column, named 'value'.
#   
#   # Our loop to find the best model with CV on the beginning
#   res <- tibble(Vario.Model = NA, Vario.SSErr = NA, Vario.Weights = NA,
#                 CV.Data_Turn = NA, Z.Score = NA)
#   
#   # Modelling Variogram with the SSE minimization
#   # All the model classes
#   model.classes <- c("matern", "exponential", "gaussian", "spherical")
#   # All the Weight Types
#   weights.types <- c("npairs", "cressie", "equal")
#   
#   for(turn in 1:nrow(dt)){
#     
#     train <- dt[-turn,]
#     test <- dt[turn,]
#     
#     # Transforming to geodata
#     dt.geo <- train %>% as.geodata()
#     
#     if(distance == 'haversine'){
#       # Variogram with Geodesic Distance
#       v <- variog.geodesic(dt.geo) 
#       dista <- 'haversine'
#       coord.x <- 'lat'
#       coord.y <- 'long'
#     }
#     if(distance == 'euclidean'){
#       aux.bin <- dt.geo$coords %>%
#         dist(method = 'euclidean') %>%
#         vectorizing_fun() 
#       
#       max.dist <- max(aux.bin)
#       
#       aux.bin1 <- aux.bin[aux.bin < max.dist] %>%
#         quantile(probs = seq(0,1, l = 12))
#       # Variogram with Euclidean Distance
#       v <- variog(geodata = dt.geo, uvec = aux.bin1)
#       
#       dista <- 'euclidean'
#       coord.x <- 'x'
#       coord.y <- 'y'
#     }
#     
#     # Modelling Variogram
#     for(j in weights.types){
#       for(i in model.classes){
#         # fit the variogram
#         ols.fit <- variofit(v, cov.model = i, weights = j, messages = T)
#         # Changing from GeoR to GSTAT form
#         # Adapting the name of the model so that it can fit in the gstat form
#         model.gstat <- as.character(i) %>%
#           stringr::str_sub(1L, 3L) %>% 
#           str_to_title()
#         
#         if(ols.fit$cov.pars[2] == 0){
#           next
#         }
#         
#         var.fit <- vgm(psill = ols.fit$cov.pars[1],
#                        model = model.gstat,
#                        range = ols.fit$cov.pars[2],
#                        nugget = ols.fit$nugget,
#                        cutoff = ols.fit$max.dist)
#         
#         # Kriging the train dataset on the test point
#         cv.fit.krige <- ordinary_kriging(train, var.fit, distance = dista,
#                                          df.coord = test[c(coord.x, coord.y)])
# 
#         # Acessing and storing CV values in our auxiliary matrix.
#         cv.pred.krige <- cv.fit.krige$pred.krige
#         cv.var.pred.krige <- cv.fit.krige$var.pred.krige
#         cv.sd.pred.krige <- cv.var.pred.krige %>% sqrt()
#         cv.resid <- test$value - cv.pred.krige
#         z.score <- cv.resid/cv.sd.pred.krige
#         
#         # Add the parameters to our auxiliary tibble
#         res <- res %>% 
#           add_row(tibble_row(Vario.Model = i, Vario.SSErr = ols.fit$value), Vario.Weights = j,
#                   CV.Data_Turn = turn, Z.Score = z.score)
#       }
#     }
#   }
#   return(res %>% drop_na())
# }
